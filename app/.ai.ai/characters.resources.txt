/* app\Http\Controllers\Admin\CharacterController.php */
<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Http\Requests\StoreCharacterRequest;
use App\Http\Requests\UpdateCharacterRequest;
use App\Http\Resources\CharacterIndexResource;
use App\Http\Resources\CharacterResource;
use App\Models\Character;
use App\Models\Category;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Inertia\Inertia;
use Inertia\Response;   
use Illuminate\Support\Str;
use App\Services\ImageService;

class CharacterController extends Controller
{
    /**
     * Display a listing of the resource.
     */
    public function index(Request $request): Response
    {
        $characters = Character::query()
                            ->when(request('search'), function ($query, $search) {
                                $query->where('name', 'like', '%' . $search . '%');
                            })
                            // orderBy('fullname', 'asc')
                            ->latest()
                            ->paginate($request->get('per_page', 15))
                            ->withQueryString();

        /*---------------------------------------------------------------------*/
        // TODO: Monitorear su funcionamiento - por ahora todo funciona correctamente
        // Verificar si la página actual es mayor que la última página disponible - si es mayor, redirigir a la última página válida, manteniendo los parámetros de búsqueda
        if ($characters->lastPage() > 0 && $request->get('page', 1) > $characters->lastPage()) {
            // Redirigir a la última página válida, manteniendo los parámetros de búsqueda
            return redirect($characters->url($characters->lastPage()));
        }
        /*---------------------------------------------------------------------*/

        return Inertia::render('Admin/Characters/Index', [
            'characters' => CharacterIndexResource::collection($characters),
            'filters' => $request->only(['search', 'per_page', 'page']),
        ]);
    }

    /**
     * Show the form for creating a new resource.
     */
    public function create(): Response
    {
        return Inertia::render('Admin/Characters/Create', [
            // 'categories' => CategoryResource::collection(Category::all()),
            'categories' => Category::select('id', 'name', 'status')->get(),
        ]);
    }

    /**
     * Store a newly created resource in storage.
     */
    public function store(StoreCharacterRequest $request, ImageService $imageService): RedirectResponse
    {
        $validated = $request->validated();

        // Procesar imagen: canvas + thumbnail
        if ($request->hasFile('picture')) {
            $filenameBase = Str::slug($request->fullname) . '-' . now()->timestamp;
            try {
                // Crea y guarda la imagen principal y el thumbnail
                $result = $imageService->makeCanvasWithThumb(
                    $request->file('picture'),  // UploadedFile
                    $filenameBase,              // nombre base (sin extensión)
                    600,                        // canvas width
                    600,                        // canvas height
                    180,                        // thumb width
                    180,                        // thumb height
                    'characters/',              // directorio principal
                    'characters/thumbs/'        // directorio thumbnails
                );

                $validated['picture'] = $result['main']; // ruta guardada de imagen principal
                $validated['picture_thumb'] = $result['thumb']; // (opcional, si tienes columna en la BD)
            } catch (\Exception $e) {
                \Log::error('Error al generar la imagen/canvas: ' . $e->getMessage());
                return to_route('admin.characters.index')
                    ->with('error', 'Error al procesar la imagen.');
            }
        }

        try {
            $character = Character::create($validated);
            $categoryIds = $request->input('category_ids', []);
            $character->categories()->attach($categoryIds);

            return to_route('admin.characters.show', $character)
                ->with('success', 'Character created successfully.');
        } catch (\Exception $e) {
            \Log::error('Error al crear el personaje: ' . $e->getMessage());
            return to_route('admin.characters.index')
                ->with('error', 'Error al crear el personaje.');
        }
    }


    public function store_original_ok_deprecated(StoreCharacterRequest $request): RedirectResponse
    {
        // 1. Obtén todos los datos que pasaron la validación.
        //    $request->validated() devuelve un array con solo los campos definidos en rules().
        $validated = $request->validated();
        // dd($validated);

        // 2. Procesa y almacena la imagen.
        //    $request->file('image') devuelve el objeto UploadedFile original.
        //    Guardamos la ruta del archivo en nuestra variable de datos validados.
        if ($request->hasFile('picture')) {
            // $validated['picture'] = $request->file('picture')->store('characters', 'public');
            // Almacenar la imagen con nombre personalizado
            $filename = Str::slug($request->fullname).'-'.now()->timestamp.'.'.$request->file('picture')->extension();
            try {
                $path = $request->file('picture')->storePubliclyAs('characters', $filename, 'public');
                $validated['picture'] = $path;
            } catch (\Exception $e) {
                // Manejar el error, por ejemplo, registrar en el log
                \Log::error('Error al almacenar la imagen: '.$e->getMessage());

                // Opcional: redirigir con un mensaje de error
                return to_route('admin.characters.index')->with('error', 'Error al almacenar la imagen.');
            }
        }

        // 3. Genera el slug a partir del fullname validado.
        // $validated['slug'] = Str::slug($validated['fullname']);

        try {
            // 4. Crea el personaje con el array de datos completo y preparado.
            //    Este es un enfoque de "Mass Assignment" limpio y seguro.
            // Character::create($validated);
            $character = Character::create($validated);

            // id de las categorias elegidas del multiselect
            // 1. Obtén el array de objetos
            // $categories = $request->input('category_ids', []);
            // dd($categories);

            // 2. Extrae solo los IDs
            $categoryIds = $request->input('category_ids', []);  // collect($categories)->pluck('id')->toArray(); // [1, 2, 3]
            // dd($categoryIds);

            // 3. Relación con datos extra de la pivot
            $character->categories()->attach(
                $categoryIds/* ,
                [
                    'elo_rating' => 1400,
                    'status'     => 1,
                ] */
            );

            // 5. Redirige con un mensaje de éxito.
            return to_route('admin.characters.show', $character)->with('success', 'Character created successfully.');
        } catch (\Exception $e) {
            // Manejar el error, por ejemplo, registrar en el log
            \Log::error('Error al crear el personaje: '.$e->getMessage());

            // Opcional: redirigir con un mensaje de error
            return to_route('admin.characters.index')->with('error', 'Error al crear el personaje.');
        }
    }

    /**
     * Display the specified resource.
     */
    public function show(Character $character): Response
    {
        // get character with categories
        // dd($character->categories()->get());

        return Inertia::render('Admin/Characters/Show', [
            // 'character' => new CharacterResource($character),
            'character' => CharacterResource::make($character)->resolve(),
            'categories' => $character->categories()->get(['id', 'name', 'slug'/* , 'category_character.elo_rating', 'category_character.status' */]), // get only name, id, and pivot elo_rating
            // 'categories' => $character->categories()->withPivot('elo_rating', 'status')->get(['id', 'name']),
        ]);
    }

    /**
     * Show the form for editing the specified resource.
     */
    public function edit(Character $character): Response
    {
        // Objetos completos de las categorías que YA tiene el personaje
        $characterCategories = $character->categories()
            ->select('categories.id', 'categories.name', 'categories.status')
            ->get();                       // Collection de objetos

        // Objetos completos de las categorías disponibles
        $categories = Category::select('id', 'name', 'status')->get();

        // dd($categories, $characterCategories);

        return Inertia::render('Admin/Characters/Edit', [
            // 'character' => new CharacterResource($character),
            'character' => CharacterResource::make($character)->resolve(),
            'categories'           => $categories,
            'characterCategories'  => $characterCategories,
        ]);
    }

    /**
     * Update the specified resource in storage.
     */
    public function update(UpdateCharacterRequest $request, Character $character, ImageService $imageService): RedirectResponse
    {
        $validated = $request->validated();

        // Procesar y reemplazar imagen si se sube una nueva
        if ($request->hasFile('picture')) {
            $filenameBase = Str::slug($validated['fullname']) . '-' . now()->timestamp;

            try {
                $result = $imageService->makeCanvasWithThumb(
                    $request->file('picture'),
                    $filenameBase,
                    600, 600, // canvas dims
                    180, 180  // thumb dims
                );

                // Eliminar antiguo archivo principal y thumb si existen
                if ($character->picture) {
                    \Storage::disk('public')->delete($character->picture);
                }
                if ($character->picture_thumb ?? false) {
                    \Storage::disk('public')->delete($character->picture_thumb);
                }

                $validated['picture'] = $result['main'];
                $validated['picture_thumb'] = $result['thumb'];
            } catch (\Exception $e) {
                \Log::error('Error al procesar la imagen: '.$e->getMessage());
                return to_route('admin.characters.show', $character)
                    ->with('error', 'Error al actualizar la imagen.');
            }
        } else {
            unset($validated['picture'], $validated['picture_thumb']);
        }

        try {
            $character->update($validated);
            $categoryIds = $request->input('category_ids', []);
            $character->categories()->sync($categoryIds);

            return to_route('admin.characters.show', $character)
                ->with('success', 'Character updated successfully.');
        } catch (\Exception $e) {
            \Log::error('Error al actualizar el personaje: '.$e->getMessage());
            return to_route('admin.characters.index')
                ->with('error', 'Error al actualizar el personaje.');
        }
    }



    public function update_original_ok_deprecated(UpdateCharacterRequest $request, Character $character): RedirectResponse
    {
        // La validación ya ocurrió automáticamente por el UpdateCharacterRequest, aqui solo obtenemos los datos validados
        $validated = $request->validated();

        // dd($validated);

        if ($request->hasFile('picture')) {
            // Almacenar la imagen con nombre personalizado
            $filename = Str::slug($request->fullname).'-'.now()->timestamp.'.'.$request->file('picture')->extension();
            try {
                $path = $request->file('picture')->storePubliclyAs('characters', $filename, 'public');
                $validated['picture'] = $path;
                // Elimina la imagen anterior si existe
                if ($character->picture) {
                    \Storage::disk('public')->delete($character->picture);
                }
            } catch (\Exception $e) {
                // Manejar el error, por ejemplo, registrar en el log
                \Log::error('Error al almacenar la imagen: '.$e->getMessage());

                // Opcional: redirigir con un mensaje de error
                return to_route('admin.characters.show', $character)->with('error', 'Error al almacenar la imagen.');
            }
        } else {
            // Si no hay archivo, no se actualiza la imagen
            // $validated['picture'] = $character->picture;
            unset($validated['picture']);
        }

        /* $character->update([
            ...$validated,
            'slug' => Str::slug($validated['fullname']),
        ]); */

        $character->update($validated);

        // Relación con datos extra de la pivot
        $character->categories()->sync($validated['category_ids']);

        // Sincronizar las categorías (attach/detach automático)
        /* $character->categories()->sync(
            $request->input('category_id', [])
        ); */

        return to_route('admin.characters.show', $character)->with('success', 'Character updated successfully.');



        // $character->update($request->validated());

        // return to_route('admin.characters.index')->with('success', 'Character updated successfully.');
    }

    /**
     * Remove the specified resource from storage.
     */
    public function destroy(Character $character): RedirectResponse
    {
        $character->delete(); // Soft Delete

        return to_route('admin.characters.index')->with('success', 'Character deleted successfully.');
    }
}

/* app\Models\Character.php */
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Character extends Model
{
    /** @use HasFactory<\Database\Factories\CharacterFactory> */
    use HasFactory, SoftDeletes; // Añadido SoftDeletes

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'fullname',
        'nickname',
        'slug',
        'bio',
        'dob',
        'gender',
        'nationality',
        'occupation',
        'picture',
        'status',
        'meta_title',
        'meta_description',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'dob' => 'date',
        'gender' => 'integer',
        'status' => 'boolean',
    ];

    // --- Relaciones ---
    public function categories(): BelongsToMany
    {
        return $this->belongsToMany(Category::class, 'category_character')
                    ->withPivot(['elo_rating', 'matches_played', 'wins', 'losses', 'win_rate', 'highest_rating', 'lowest_rating', 'rating_deviation', 'last_match_at', 'is_featured', 'sort_order', 'status'])
                    ->withTimestamps();
    }

    public function surveys(): BelongsToMany
    {
        return $this->belongsToMany(Survey::class, 'character_survey')
                    ->withPivot(['survey_matches', 'survey_wins', 'survey_losses', 'survey_ties', 'is_active', 'sort_order'])
                    ->withTimestamps();
    }

    public function votesAsWinner(): HasMany
    {
        return $this->hasMany(Vote::class, 'winner_id');
    }

    public function votesAsLoser(): HasMany
    {
        return $this->hasMany(Vote::class, 'loser_id');
    }

    public function combinatoricsAsCharacter1(): HasMany
    {
        return $this->hasMany(Combinatoric::class, 'character1_id');
    }

    public function combinatoricsAsCharacter2(): HasMany
    {
        return $this->hasMany(Combinatoric::class, 'character2_id');
    }
}


/* app\Http\Requests\StoreCharacterRequest.php */
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Support\Str;

class StoreCharacterRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        // Ej: return auth()->user()->type === 1; // Solo admins
        return true; // Ajustar según lógica de autorización
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        return [
            'fullname' => 'required|string|max:255|unique:characters,fullname',
            'nickname' => 'nullable|string|max:255',
            'slug' => 'required|string|max:255|unique:characters,slug',
            'bio' => 'nullable|string',
            'dob' => 'nullable|date',
            'gender' => 'required|integer|in:0,1,2,3', // 0=otro, 1=masculino, 2=femenino, 3=no-binario
            'nationality' => 'nullable|string|max:255',
            'occupation' => 'nullable|string|max:255',
            'picture' => ['required', 'image', 'max:2048', 'mimes:jpeg,jpg,png,gif,svg'],
            // 'picture_url' => ['nullable', 'string', 'max:255'],
            'status' => 'required|boolean',
            'meta_title' => 'nullable|string|max:255',
            'meta_description' => 'nullable|string|max:500',

            'category_ids' => 'required|array', // Array de IDs de categorías
            'category_ids.*' => 'exists:categories,id', // Cada ID debe existir en la tabla de categorías
        ];
    }

    /**
     * Prepare the data for validation.
     *
     * Este método es perfecto para preparar datos antes de que se validen.
     * Genera automáticamente el slug si no se proporciona.
     */
    protected function prepareForValidation(): void
    {
        // Aquí podemos añadir el slug a los datos de la petición.
        // Lo haremos en el controlador para más claridad en este caso.
        $this->merge([
            'slug' => $this->slug ?? Str::slug($this->fullname),
        ]);
    }
}


/* app\Http\Requests\UpdateCharacterRequest.php */
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;
use Illuminate\Validation\Rule;
use Illuminate\Support\Str;

class UpdateCharacterRequest extends FormRequest
{
    /**
     * Determine if the user is authorized to make this request.
     */
    public function authorize(): bool
    {
        // Ej: return auth()->user()->type === 1; // Solo admins
        return true; // Ajustar según lógica de autorización
    }

    /**
     * Get the validation rules that apply to the request.
     *
     * @return array<string, \Illuminate\Contracts\Validation\ValidationRule|array<mixed>|string>
     */
    public function rules(): array
    {
        // $characterId = $this->route('character'); // Obtiene el ID del parámetro de la ruta

        return [
            'fullname' => ['required', 'string', 'max:255', 'unique:characters,fullname,' . $this->character->id],// ['required', 'string', 'max:255', Rule::unique('characters', 'fullname')->ignore($characterId)],
            'nickname' => 'nullable|string|max:255',
            'slug' => ['required', 'string', 'max:255', 'unique:characters,slug,' . $this->character->id],// ['required', 'string', 'max:255', Rule::unique('characters', 'slug')->ignore($characterId)],
            'bio' => 'nullable|string',
            'dob' => 'nullable|date',
            'gender' => 'required|integer|in:0,1,2,3',
            'nationality' => 'nullable|string|max:255',
            'occupation' => 'nullable|string|max:255',
            'picture' => ['nullable', 'image', 'max:2048', 'mimes:jpeg,jpg,png,gif,svg'],   // 'picture' => 'nullable|image|mimes:jpeg,jpg,png,gif,svg|max:2048',
            'status' => 'required|boolean',
            'meta_title' => 'nullable|string|max:255',
            'meta_description' => 'nullable|string|max:500',

            'category_ids' => 'required|array', // Array de IDs de categorías
            'category_ids.*' => 'exists:categories,id', // Cada ID debe existir en la tabla de categorías
        ];
    }

    /**
     * Prepare the data for validation.
     *
     * Este método es perfecto para preparar datos antes de que se validen.
     * Genera automáticamente el slug si no se proporciona.
     */
    protected function prepareForValidation(): void
    {
        // Aquí podemos añadir el slug a los datos de la petición.
        // Lo haremos en el controlador para más claridad en este caso.
        $this->merge([
            'slug' => $this->slug ?? Str::slug($this->fullname),
        ]);
    }
}


/* app\Http\Resources\CharacterIndexResource.php */
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\Facades\Storage;

class CharacterIndexResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        // return parent::toArray($request);
        $picture = $this->picture; // Ej: 'characters/juan-12345678.jpg'
        $thumbUrl = null;
        

        if ($picture) {
            // Extraer path relativo y extension
            $info = pathinfo($picture);
            // $info['dirname'] = 'characters', $info['filename'] = 'juan-12345678', $info['extension'] = 'jpg'
    
            // Construir ruta del thumb: 'characters/thumbs/juan-12345678_thumb.jpg'
            $thumbRelPath = $info['dirname'].'/thumbs/'.$info['filename'].'_thumb.'.$info['extension'];
            $thumbUrl = Storage::url($thumbRelPath);
        }

        return [
            'id' => $this->id,
            'fullname' => $this->fullname,
            'nickname' => $this->nickname,
            'gender' => $this->gender,
            'thumbnail_url' => $thumbUrl,
            'status' => $this->status,
            'created_at_formatted' => $this->created_at->translatedFormat('Y-m-d H:i:s'),
        ];
    }
}


/* app\Http\Resources\CharacterResource.php */
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;
use Illuminate\Support\Facades\Storage;

class CharacterResource extends JsonResource
{
    /**
     * Transform the resource into an array.
     *
     * @return array<string, mixed>
     */
    public function toArray(Request $request): array
    {
        return [
            'id' => $this->id,
            'fullname' => $this->fullname,
            'nickname' => $this->nickname,
            'slug' => $this->slug,
            'bio' => $this->bio,
            'dob' => $this->dob ? $this->dob->format('Y-m-d') : null,
            'dob_for_humans' => $this->dob ? $this->dob->diffForHumans(['parts' => 3]) : null,
            'gender' => $this->gender,
            'nationality' => $this->nationality,
            'occupation' => $this->occupation,
            'picture' => $this->picture, // $this->picture ? Storage::url($this->picture) : null,
            'picture_url' => $this->picture ? Storage::url($this->picture) : null,
            // 'picture_thumb' => $this->picture ? $this->picture : null,
            'status' => $this->status,
            'meta_title' => $this->meta_title,
            'meta_description' => $this->meta_description,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,

            'created_at_formatted' => $this->created_at->translatedFormat('Y-m-d H:i:s'),
            'updated_at_formatted' => $this->updated_at->translatedFormat('Y-m-d H:i:s'),
            // 'deleted_at' => $this->when($this->trashed(), $this->deleted_at),
        ];
    }
}