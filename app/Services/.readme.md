Análisis Inicial de los Servicios
Antes de escribir código, definamos claramente qué hará cada servicio y qué interacciones tendrán con el modelo de datos y la lógica de negocio:

CombinatoricService: Responsable de:

Generar Combinaciones Iniciales: Dado un conjunto de personajes para una encuesta, crear todas las combinaciones posibles (C(n, 2)) en la tabla combinatorics. Esta lógica probablemente se dispare al crear/actualizar una encuesta (posiblemente via un Observer o un servicio dedicado llamado desde el controlador).
Seleccionar Siguiente Pareja: Dado un ID de encuesta y un usuario, determinar cuál es la próxima pareja de personajes a mostrar. Esto implica aplicar la selection_strategy (cooldown, random, elo_based, etc.) a los registros de combinatorics asociados a la encuesta. Esta lógica se usará cuando el usuario inicie/continúe una encuesta o después de emitir un voto.
Actualizar Estado de Combinación: Marcar una combinación específica como usada o actualizar métricas como total_comparisons, last_used_at. Esta lógica se usará inmediatamente después de que el usuario vote y se registre el voto.

SurveyProgressService: Responsable de:

Verificar Estado del Usuario: Dado un ID de encuesta y un ID de usuario, verificar si el usuario ya tiene una entrada en survey_user, si está completada, en progreso, etc.
Iniciar Sesión de Votación: Si no existe entrada, crearla en survey_user con valores iniciales (progress_percentage = 0, total_votes = 0, started_at, is_completed = false).
Actualizar Progreso: Dado un ID de encuesta y usuario, incrementar total_votes, recalcular progress_percentage, actualizar last_activity_at. Esto ocurre después de procesar un voto.
Finalizar Sesión de Votación: Marcar is_completed = true en survey_user y posiblemente guardar la completed_at y el completion_time. Esto ocurre cuando se alcanza el final de la encuesta para el usuario (lógica a definir).

EloRatingService: Responsable de:

Calcular Nuevos Ratings ELO: Dados dos personajes (ganador/perdedor o empate) y sus ratings ELO actuales en la categoría de la encuesta, calcular los nuevos ratings basados en la fórmula ELO.
Aplicar Nuevos Ratings: Actualizar los campos relevantes (elo_rating, matches_played, wins, losses, win_rate, highest_rating, lowest_rating, last_match_at) en la tabla pivote category_character.
Aislamiento: Ser independiente del resto del sistema para facilitar futuras modificaciones (Glicko-2). Idealmente, esta clase no debería conocer directamente Vote, Survey, User, etc., sino recibir IDs y ratings, y devolver los nuevos ratings o aplicarlos internamente.

Elección de Patrones y Estructura

Clases de Acción Única (**invoke): Son útiles para servicios con una única responsabilidad bien definida y una única operación principal. Por ejemplo, un servicio ProcessVoteAction que reciba todos los datos del voto, coordine las llamadas a otros servicios y realice la transacción completa. Esta podría ser una opción para EloRatingService si su única función es calcular y aplicar, o para un servicio de alto nivel como ProcessVoteAction.
Servicios con Múltiples Métodos: Son más apropiados cuando hay varias operaciones lógicamente relacionadas pero distintas, como en CombinatoricService (generar, seleccionar, actualizar) o SurveyProgressService (verificar, iniciar, actualizar, finalizar). Esta estructura ofrece más flexibilidad para ser usada por diferentes controladores o servicios.
Controladores de Acción Única: Similar a servicios **invoke, pero para controladores. Útiles para endpoints muy específicos. Por ejemplo, SurveyVoteController probablemente tenga un solo método store para procesar votos, pero PublicSurveyController tiene múltiples responsabilidades (index, show). Un controlador ProcessVoteController podría ser \_\_invoke si solo recibe y procesa un voto.

Decisión: Dado el análisis, usaré Servicios con Múltiples Métodos para CombinatoricService y SurveyProgressService debido a la variedad de operaciones relacionadas. Para EloRatingService, usaré múltiples métodos (calculate, apply) para mantener claridad y permitir reutilización. La lógica central de procesar un voto (validar, actualizar combinatorics, aplicar ELO, actualizar progreso) la encapsularé en un método específico dentro del SurveyVoteController, o posiblemente en un nuevo servicio de acción única tipo ProcessVoteAction si se vuelve muy compleja, pero por ahora, el controlador puede manejarla limpiamente si se delega a los servicios específicos.
